<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="robots" content="noindex" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BitLoTop Airdrop</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; background:#f7fafc; padding:20px; color:#111; }
    .card { background:#fff; max-width:980px; margin:20px auto; padding:20px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    input, textarea, button, select { font-size:14px; }
    textarea { width:100%; min-height:160px; }
    .row { display:flex; gap:12px; align-items:center; margin-top:10px; flex-wrap:wrap; }
    .muted { color:#666; font-size:13px; }
    .log { white-space:pre-wrap; background:#0b1220; color:#e6f3ff; padding:12px; border-radius:8px; max-height:300px; overflow:auto; }
    label { font-weight:600; }
    .summary { background:#f1f5f9; padding:10px; border-radius:8px; }
    .small { font-size:13px; color:#555; }
    .btn { padding:8px 12px; border-radius:6px; cursor:pointer; }
    .btn-primary { background:#16a34a; color:#fff; border:none; }
    .btn-ghost { background:#e2e8f0; border:none; }
  </style>
</head>
<body>
  <div class="card">
    <h1>BitLoTop Airdrop</h1>
    <p class="muted">Private airdrop tool — sequential sends but with batch preview & gas estimation. Test with a few addresses first.</p>

    <div class="row">
      <button id="btnConnect" class="btn btn-ghost">Connect Wallet</button>
      <div id="account" class="small">Not connected</div>
      <div id="balances" class="small" style="margin-left:auto"></div>
    </div>

    <hr/>

    <div>
      <label>Token to send</label>
      <div class="row" style="align-items:center">
        <select id="tokenSelect">
          <option value="0x8a128ae8823202e3ad53431319034a2ede9be9cc">BitLoTop — 0x8a128a...9be9cc</option>
          <option value="">Custom token (paste address)</option>
        </select>
        <input id="tokenAddress" placeholder="0x..." style="flex:1; padding:8px; border-radius:6px; border:1px solid #ddd;" value="0x8a128ae8823202e3ad53431319034a2ede9be9cc" />
        <button id="btnLoadToken" class="btn btn-ghost">Load token</button>
      </div>
      <div class="row" style="margin-top:8px;">
        <div class="muted">Symbol: <span id="tokenSymbol">BitLoTop</span></div>
        <div class="muted" style="margin-left:12px">Decimals: <span id="tokenDecimals">18</span></div>
        <div class="muted" style="margin-left:12px">Your token balance: <span id="tokenBalance">-</span></div>
      </div>
    </div>

    <hr/>

    <div>
      <label>Upload CSV (address,amount) or paste below:</label><br/>
      <input id="file" type="file" accept=".csv,.txt" />
      <textarea id="csv" placeholder="0xabc...,1.0
0xdef...,2.5"></textarea>
      <div class="row" style="margin-top:8px;">
        <div>Recipients: <b id="count">0</b></div>
        <div>Total tokens to send: <b id="total">0</b></div>
        <div>Estimated gas per tx: <b id="estGas">-</b></div>
        <div style="margin-left:auto"><button id="btnPreview" class="btn btn-ghost">Preview</button> <button id="btnStart" class="btn btn-primary">Start Airdrop</button></div>
      </div>
      <div class="muted" style="margin-top:6px">You can select the token above or paste any BEP-20 token address. The UI will fetch symbol/decimals and your token balance.</div>
    </div>

    <hr/>

    <div>
      <h3>Logs</h3>
      <div id="log" class="log">Waiting for action...</div>
    </div>

    <hr/>

    <div class="summary">
      <strong>Summary</strong>
      <div id="summaryText" class="small">No preview yet.</div>
    </div>

    <div style="margin-top:12px" class="small muted">This page is static and runs in the browser. It does <em>sequential</em> transfers (one transaction per recipient). Use the multisend contract variant for a single on-chain batch (not included here).</div>
  </div>

<script>
// Minimal Web3 helpers using window.ethereum (EIP-1193). No external libs required.
const logEl = document.getElementById('log');
function log(...args){ logEl.textContent += "\n" + args.join(' '); logEl.scrollTop = logEl.scrollHeight; }
function clearLog(){ logEl.textContent = ''; }

let provider = null;
let account = null;

async function connect() {
  if(!window.ethereum){ alert('MetaMask or other injected wallet required'); return; }
  provider = window.ethereum;
  try {
    const accounts = await provider.request({ method: 'eth_requestAccounts' });
    account = accounts[0];
    document.getElementById('account').textContent = 'Connected: ' + account;
    log('Connected', account);
    await refreshBalances();
  } catch(e) {
    log('Connection failed', e.message || e);
  }
}

document.getElementById('btnConnect').onclick = connect;

async function refreshBalances(){
  if(!account) return;
  try {
    const bnb = await provider.request({ method:'eth_getBalance', params:[account, 'latest'] });
    const bnbEth = parseInt(bnb,16) / (10**18);
    document.getElementById('balances').textContent = 'BNB: ' + bnbEth.toFixed(6);
  } catch(e){ log('BNB balance error', e.message || e); }
  await loadTokenInfo(); // refresh token balance
}

// Utility: pad hex to 32 bytes
function padHex(hex){ if(hex.startsWith('0x')) hex = hex.slice(2); return '0x' + hex.padStart(64,'0'); }
function strip0x(hex){ return hex.startsWith('0x') ? hex.slice(2) : hex; }

// ERC20 helpers (uses low-level eth_call)
async function erc20_call(contract, data){
  try {
    return await provider.request({ method:'eth_call', params:[{ to: contract, data: data }, 'latest'] });
  } catch(e) {
    log('eth_call error', e.message || e);
    throw e;
  }
}

async function getTokenSymbol(contract){
  // symbol() => 0x95d89b41
  try{
    const res = await erc20_call(contract, '0x95d89b41');
    if(!res || res === '0x') return null;
    const hex = res.slice(2);
    let str = '';
    for(let i=0;i<hex.length;i+=2){
      const code = parseInt(hex.substr(i,2),16);
      if(code === 0) break;
      str += String.fromCharCode(code);
    }
    return str || null;
  }catch(e){ return null; }
}

async function getTokenDecimals(contract){
  // decimals() => 0x313ce567
  try{
    const res = await erc20_call(contract, '0x313ce567');
    if(!res || res === '0x') return 18;
    return parseInt(res,16);
  } catch(e){ return 18; }
}

async function getTokenBalance(contract, owner){
  // balanceOf(address) => 0x70a08231 + padded address
  const data = '0x70a08231' + strip0x(owner).padStart(64,'0');
  const res = await erc20_call(contract, data);
  if(!res || res === '0x') return 0n;
  return BigInt(res);
}

document.getElementById('tokenSelect').onchange = function(e){
  const v = e.target.value;
  if(v) document.getElementById('tokenAddress').value = v;
};

document.getElementById('btnLoadToken').onclick = loadTokenInfo;

async function loadTokenInfo(){
  const addr = document.getElementById('tokenAddress').value.trim();
  if(!addr || !/^0x[0-9a-fA-F]{40}$/.test(addr)){ alert('Invalid token address'); return; }
  document.getElementById('tokenSymbol').textContent = '...';
  document.getElementById('tokenDecimals').textContent = '...';
  try{
    const sym = await getTokenSymbol(addr) || 'TKN';
    const dec = await getTokenDecimals(addr);
    document.getElementById('tokenSymbol').textContent = sym;
    document.getElementById('tokenDecimals').textContent = dec;
    if(account){
      const bal = await getTokenBalance(addr, account);
      const display = Number(bal) / (10 ** dec);
      document.getElementById('tokenBalance').textContent = display.toString();
    }
    log('Token loaded', sym, 'decimals', dec);
  }catch(e){ log('Load token failed', e.message || e); }
}

document.getElementById('file').onchange = (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = (ev)=>{ document.getElementById('csv').value = ev.target.result; preview(); };
  r.readAsText(f);
};

function parseList(){
  const text = document.getElementById('csv').value.trim();
  if(!text) return [];
  const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const out = [];
  for(const line of lines){
    const parts = line.split(/[, \t]+/).map(p=>p.trim());
    if(parts.length < 2) continue;
    const a = parts[0], am = parts[1];
    if(!/^0x[0-9a-fA-F]{40}$/.test(a)){ log('Skipping invalid address', a); continue; }
    if(isNaN(Number(am))){ log('Skipping invalid amount', am); continue; }
    out.push({address: a, amount: am});
  }
  return out;
}

function preview(){
  clearLog();
  const list = parseList();
  document.getElementById('count').textContent = list.length;
  // compute total by decimals
  const dec = parseInt(document.getElementById('tokenDecimals').textContent || '18');
  let total = 0n;
  for(const r of list){
    const parts = r.amount.split('.');
    let whole = BigInt(parts[0] || '0');
    let frac = '0';
    if(parts[1]) frac = parts[1].padEnd(dec,'0').slice(0,dec);
    const val = whole * BigInt(10)**BigInt(dec) + BigInt(frac);
    total += val;
  }
  const totalHuman = total === 0n ? '0' : (Number(total) / (10 ** dec)).toString();
  document.getElementById('total').textContent = totalHuman;
  document.getElementById('summaryText').textContent = `Recipients: ${list.length} — Total tokens: ${totalHuman}`;
  (async ()=>{
    if(list.length === 0) return;
    const tokenAddr = document.getElementById('tokenAddress').value.trim();
    try{
      const first = list[0];
      const dec = parseInt(document.getElementById('tokenDecimals').textContent || '18');
      const method = 'a9059cbb';
      const toP = strip0x(first.address).padStart(64,'0');
      const parts = first.amount.split('.');
      let whole = BigInt(parts[0] || '0');
      let frac = '0';
      if(parts[1]) frac = parts[1].padEnd(dec,'0').slice(0,dec);
      const amount = whole * BigInt(10)**BigInt(dec) + BigInt(frac);
      const amountHex = amount.toString(16).padStart(64,'0');
      const data = '0x' + method + toP + amountHex;
      const from = account;
      const estimate = await provider.request({ method:'eth_estimateGas', params:[{from: from, to: tokenAddr, data: data}] });
      const est = parseInt(estimate,16);
      document.getElementById('estGas').textContent = est.toString();
      log('Estimated gas per transfer', est);
      try{
        const gp = await provider.request({ method:'eth_gasPrice', params:[] });
        const gpInt = parseInt(gp,16);
        const approxBNB = gpInt * est / (10**18);
        document.getElementById('summaryText').textContent += ` — Est gas (per tx): ${est} gas (~${approxBNB.toFixed ? approxBNB.toFixed(6) : approxBNB} BNB at current gasPrice)`;
      }catch(e){ }
    }catch(e){ log('Gas estimate failed', e.message || e); }
  })();
}

document.getElementById('btnPreview').onclick = preview;

async function sendAirdrop(){
  const list = parseList();
  if(!list.length){ alert('No recipients'); return; }
  if(!account){ alert('Connect wallet first'); return; }
  const tokenAddr = document.getElementById('tokenAddress').value.trim();
  const dec = parseInt(document.getElementById('tokenDecimals').textContent || '18');
  if(!confirm(`Send to ${list.length} recipients? This will create ${list.length} transactions from your wallet.`)) return;
  for(let i=0;i<list.length;i++){
    const r = list[i];
    try{
      const method = 'a9059cbb';
      const toP = strip0x(r.address).padStart(64,'0');
      const parts = r.amount.split('.');
      let whole = BigInt(parts[0] || '0');
      let frac = '0';
      if(parts[1]) frac = parts[1].padEnd(dec,'0').slice(0,dec);
      const amount = whole * BigInt(10)**BigInt(dec) + BigInt(frac);
      const amountHex = amount.toString(16).padStart(64,'0');
      const data = '0x' + method + toP + amountHex;
      log(`Sending ${r.amount} to ${r.address} ...`);
      const txParams = { from: account, to: tokenAddr, data: data };
      try{
        const est = await provider.request({ method:'eth_estimateGas', params:[txParams] });
        txParams.gas = est;
      }catch(e){ }
      const txHash = await provider.request({ method:'eth_sendTransaction', params:[txParams] });
      log('Tx sent:', txHash);
      await waitForTx(txHash);
      log('Confirmed:', txHash);
      try{ await loadTokenInfo(); }catch(e){}
    }catch(e){
      log('Failed at', r.address, e.message || e);
      return;
    }
  }
  log('Airdrop complete.');
}

document.getElementById('btnStart').onclick = sendAirdrop;

async function waitForTx(txHash){
  log('Waiting for confirmation', txHash);
  while(true){
    try{
      const receipt = await provider.request({ method:'eth_getTransactionReceipt', params:[txHash] });
      if(receipt && receipt.blockNumber){ return receipt; }
      await new Promise(r=>setTimeout(r,3000));
    }catch(e){ await new Promise(r=>setTimeout(r,3000)); }
  }
}

window.addEventListener('load', async ()=>{ try{ await loadTokenInfo(); }catch(e){} log('App ready — connect wallet to begin.'); });
</script>
</body>
</html>
